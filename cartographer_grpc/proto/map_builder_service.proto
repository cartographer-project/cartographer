// Copyright 2017 The Cartographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

import "cartographer/mapping/proto/pose_graph.proto";
import "cartographer/mapping/proto/submap_visualization.proto";
import "cartographer/mapping/proto/trajectory_builder_options.proto";
import "cartographer/sensor/proto/sensor.proto";
import "cartographer/transform/proto/transform.proto";
import "google/protobuf/empty.proto";

package cartographer_grpc.proto;

message AddTrajectoryRequest {
  repeated string expected_sensor_ids = 1;
  cartographer.mapping.proto.TrajectoryBuilderOptions
      trajectory_builder_options = 2;
}

message SensorMetadata {
  int32 trajectory_id = 1;
  string sensor_id = 2;
}

message AddTrajectoryResponse {
  int32 trajectory_id = 1;
}

message AddOdometryDataRequest {
  SensorMetadata sensor_metadata = 1;
  cartographer.sensor.proto.OdometryData odometry_data = 2;
}

message AddImuDataRequest {
  SensorMetadata sensor_metadata = 1;
  cartographer.sensor.proto.ImuData imu_data = 2;
}

message AddRangefinderDataRequest {
  SensorMetadata sensor_metadata = 1;
  cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
}

message AddFixedFramePoseDataRequest {
  SensorMetadata sensor_metadata = 1;
  cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
}

message FinishTrajectoryRequest {
  int32 trajectory_id = 1;
}

message ReceiveLocalSlamResultsRequest {
  int32 trajectory_id = 1;
}

message ReceiveLocalSlamResultsResponse {
  int32 trajectory_id = 1;
  int64 timestamp = 2;
  cartographer.transform.proto.Rigid3d local_pose = 3;
  cartographer.sensor.proto.RangeData range_data = 4;
  cartographer.mapping.proto.NodeId node_id = 5;
}

message GetSubmapRequest {
  cartographer.mapping.proto.SubmapId submap_id = 1;
}

message GetSubmapResponse {
  cartographer.mapping.proto.SubmapQuery.Response submap_query_response = 1;
  string error_msg = 2;
}

message TrajectoryNodePose {
  cartographer.mapping.proto.NodeId node_id = 1;
  cartographer.transform.proto.Rigid3d global_pose = 2;
  bool has_constant_data = 3;
}

message GetTrajectoryNodePosesResponse {
  repeated TrajectoryNodePose node_poses = 1;
}

message SubmapPose {
  cartographer.mapping.proto.SubmapId submap_id = 1;
  int32 submap_version = 2;
  cartographer.transform.proto.Rigid3d global_pose = 3;
}

message GetAllSubmapPosesResponse {
  repeated SubmapPose submap_poses = 1;
}

service MapBuilderService {
  // Starts a new trajectory and returns its index.
  rpc AddTrajectory(AddTrajectoryRequest) returns (AddTrajectoryResponse);

  // Adds odometry data from the sensor with id 'sensor_metadata.sensor_id' to
  // the trajectory corresponding to 'sensor_metadata.trajectory_id'.
  rpc AddOdometryData(stream AddOdometryDataRequest)
      returns (google.protobuf.Empty);

  // Same for IMU data.
  rpc AddImuData(stream AddImuDataRequest) returns (google.protobuf.Empty);

  // Same for range-finder data.
  rpc AddRangefinderData(stream AddRangefinderDataRequest)
      returns (google.protobuf.Empty);

  // Same for fixed-frame pose data.
  rpc AddFixedFramePoseData(stream AddFixedFramePoseDataRequest)
      returns (google.protobuf.Empty);

  // Requests the server to send a stream of local SLAM results for the given
  // 'trajectory_id'.
  rpc ReceiveLocalSlamResults(ReceiveLocalSlamResultsRequest)
      returns (stream ReceiveLocalSlamResultsResponse);

  // Marks a trajectory corresponding to 'trajectory_id' as finished,
  // i.e. no further sensor data is expected.
  rpc FinishTrajectory(FinishTrajectoryRequest) returns (google.protobuf.Empty);

  // Retrieves a single submap.
  rpc GetSubmap(GetSubmapRequest) returns (GetSubmapResponse);

  // Returns the current optimized trajectory poses.
  rpc GetTrajectoryNodePoses(google.protobuf.Empty)
      returns (GetTrajectoryNodePosesResponse);

  // Returns the current optimized submap poses.
  rpc GetAllSubmapPoses(google.protobuf.Empty)
      returns (GetAllSubmapPosesResponse);
}
